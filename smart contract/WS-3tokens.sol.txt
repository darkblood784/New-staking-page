// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract Staking is Ownable {
    using SafeERC20 for IERC20;

    struct StakeInfo {
        uint256 stakedAmount;
        uint256 stakedAt;
        uint256 stakeEnd;
        uint256 rewards;
    }

    IERC20 public immutable USDT;
    IERC20 public immutable WETH;
    IERC20 public immutable WBTC;
    address public immutable hotWallet;

    mapping(address => uint256) public totalStakedAmount;
    mapping(address => mapping(address => StakeInfo)) public userStakeInfos;
    bool public testMode = false;

    event Staked(address indexed stakerAddress, address tokenAddress, uint256 amount, string message);
    event Unstaked(address indexed stakerAddress, address tokenAddress, uint256 amount, string message);
    event Withdrawn(address indexed owner, address tokenAddress, uint256 amount, string message);

    constructor(
        address _usdtAddress,
        address _wethAddress,
        address _wbtcAddress,
        address _hotWallet
    ) Ownable(msg.sender) {
        USDT = IERC20(_usdtAddress);
        WETH = IERC20(_wethAddress);
        WBTC = IERC20(_wbtcAddress);
        hotWallet = _hotWallet;
    }

    function toggleTestMode(bool _testMode) external onlyOwner {
        testMode = _testMode;
    }

    function stake(address tokenAddress, uint8 durationInMonths, uint256 amount) external {
        require(
            tokenAddress == address(USDT) || tokenAddress == address(WBTC) || tokenAddress == address(WETH),
            "Invalid token address"
        );
        require(userStakeInfos[msg.sender][tokenAddress].stakedAmount == 0, "Already staked");

        IERC20(tokenAddress).safeTransferFrom(msg.sender, address(this), amount);
        IERC20(tokenAddress).safeTransfer(hotWallet, amount);

        _stake(msg.sender, tokenAddress, durationInMonths, amount);
        emit Staked(msg.sender, tokenAddress, amount, "Stake successful");
    }

    function unstake(address tokenAddress) external {
        require(
            tokenAddress == address(USDT) || tokenAddress == address(WBTC) || tokenAddress == address(WETH),
            "Invalid token address"
        );
        require(userStakeInfos[msg.sender][tokenAddress].stakedAmount > 0, "No staked token");

        uint256 stakedAmount = userStakeInfos[msg.sender][tokenAddress].stakedAmount;
        uint256 totalToReturn;

        if (!testMode && block.timestamp < userStakeInfos[msg.sender][tokenAddress].stakeEnd) {
            uint256 penalty = (stakedAmount * 6) / 100;
            totalToReturn = stakedAmount - penalty;
            emit Unstaked(msg.sender, tokenAddress, totalToReturn, "Unstake successful with 6% penalty applied");
        } else {
            uint256 rewards = userStakeInfos[msg.sender][tokenAddress].rewards;
            totalToReturn = stakedAmount + rewards;
            emit Unstaked(msg.sender, tokenAddress, totalToReturn, "Unstake successful");
        }

        require(
            IERC20(tokenAddress).balanceOf(hotWallet) >= totalToReturn,
            "Insufficient balance in hot wallet"
        );

        IERC20(tokenAddress).safeTransferFrom(hotWallet, msg.sender, totalToReturn);
        totalStakedAmount[tokenAddress] -= stakedAmount;

        userStakeInfos[msg.sender][tokenAddress].stakedAmount = 0;
        userStakeInfos[msg.sender][tokenAddress].rewards = 0;
    }

    function withdraw(address tokenAddress, uint256 amount) external onlyOwner {
        uint256 contractBalance = IERC20(tokenAddress).balanceOf(address(this));
        uint256 totalDeposits = totalStakedAmount[tokenAddress];
        require(contractBalance > totalDeposits, "No profits to withdraw");

        uint256 profit = contractBalance - totalDeposits;
        require(amount <= profit, "Insufficient profits");

        IERC20(tokenAddress).safeTransfer(owner(), amount);
        emit Withdrawn(owner(), tokenAddress, amount, "Profit withdrawal successful");
    }

    function _stake(address stakerAddress, address tokenAddress, uint8 durationInMonths, uint256 amount) internal {
        require(durationInMonths == 1 || durationInMonths == 6 || durationInMonths == 12, "Invalid staking duration");

        uint256 currentTimestamp = block.timestamp;
        uint256 stakeEnd = testMode ? currentTimestamp : currentTimestamp + (durationInMonths * 30 days);
        require(stakeEnd > currentTimestamp, "Duration overflow error");

        uint256 rewards = testMode ? 0 : _calculateRewards(durationInMonths, amount);
        userStakeInfos[stakerAddress][tokenAddress] = StakeInfo({
            stakedAmount: amount,
            stakedAt: currentTimestamp,
            stakeEnd: stakeEnd,
            rewards: rewards
        });

        totalStakedAmount[tokenAddress] += amount;
    }

    function _calculateRewards(uint256 durationInMonths, uint256 amount) internal pure returns (uint256 rewards) {
        uint256 rewardRate;
        if (durationInMonths == 1) {
            rewardRate = 15; 
        } else if (durationInMonths == 6) {
            rewardRate = 24;
        } else {
            rewardRate = 36;
        }
        rewards = (amount * rewardRate) / 100;
    }
}
